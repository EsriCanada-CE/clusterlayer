define([
  "esri/layers/GraphicsLayer",
  "esri/layers/FeatureLayer",
  "esri/symbols/TextSymbol",
  "esri/tasks/support/Query",
  "esri/Graphic",
  "esri/geometry/support/webMercatorUtils",
  "dojo/_base/declare",
  "dojo/_base/lang",
  "dojo/_base/array",
  "dojo/on",
  "require"
], function(
  GraphicsLayer,
  FeatureLayer,
  TextSymbol,
  Query,
  Graphic,
  webMercatorUtils,
  declare,
  lang,
  array,
  on,
  require
){

  var clusterRenderer = {
    type: "simple",
    symbol: {
      type: "simple-marker",
      style: "circle",
      size: 10,
      color: [255, 255, 255, 0.6],
      outline: {
        width: 1.5,
        color: "red",
        style: "solid"
      }
    },
    visualVariables: [{
      type: "size",
      field: "point_count",
      minDataValue: 3,
      maxDataValue: 1000,
      // minimum size to render minDataVal at specified view scales
      minSize: {
        type: "size",
        valueExpression: "$view.scale",
        stops: [
          { value: 1128,      size: "20px" },
          { value: 591657528, size: "12px" }
        ]
      },
      // maximum size to render maxDataVal at specified view scales
      maxSize: {
        type: "size",
        valueExpression: "$view.scale",
        stops: [
          { value: 1128,      size: "60px" },
          { value: 288895,    size: "50px" },
          { value: 73957191,  size: "40px" },
          { value: 591657528, size: "12px" }
        ]
      }
    }]
  };

  // Default cluster fields...these will always be added as attributes for the
  // features generated by th supercluster module.
  var clusterFields = [{
    name: "cluster_id",
    alias: "Cluster ID in Local Index",
    type: "oid"
  }, {
    name: "point_count",
    alias: "Total Points in Cluster Recorded",
    type: "long"
  }, {
    name: "point_count_abbreviated",
    alias: "Total Points in Cluster (abbreviated)",
    type: "string"
  }];

  // A default cluster popup template...
  var clusterPopupTemplate = {
    title: "Cluster Info",
    content: [{
      type: "fields",
      fieldInfos: [{
        fieldName: "cluster_id",
        label: "Cluster ID in Local Index",
        visible: true
      }, {
        fieldName: "point_count",
        label: "Total Points in Cluster",
        visible: true
      }, {
        fieldName: "point_count_abbreviated",
        label: "Total Points in Cluster (abbreviated)",
        visible: true
      }]
    }]
  };

  var clusterLabelSymbol = {
    type: "text",
    color: "black",
    haloColor: "blue",
    haloSize: "40px",
    text: "",
    xoffset: 0,
    yoffset: "-4px",
    font: {
      size: "12px",
      family: "sans-serif",
      weight: "bolder"
    }
  }

  return FeatureLayer.createSubclass({
    constructor: function(opts){

      this.opts = opts;
      this.featureLayerOpts = {};
      
      this.worker = new Worker(require.toUrl("./ClusterWorker.js"));
      this.worker.onmessage = lang.hitch(this, function(e) {
        if (e.data.workerReady) {
          // message received when the worker has loaded, but needs
          // a url to a script with the supercluster module.
          this.worker.postMessage({
            supercluster: require.toUrl("./") + "../node_modules/supercluster/dist/supercluster.js"
          });
        } else if (e.data.superclusterReady) {
          // The supercluster module is now loaded in the worker.
          this.clusterWorkerReady = true;
          // If the layer is already added to a map view, then  
          // call the initClusterLayer() method to get things started.
          if (this.view) this.initClusterLayer();
        } else if (e.data.indexReady) {
          // When the supercluster index is finished being 
          // prepared by the worker, we can start drawing the
          // clusters on the map.
          this.clusterIndexReady = true;
          this.requestClusters(true);
        } else {
          // This will be a message from the worker containing
          // clusters for the current zoom & extent.
          this.displayClusters(e.data);
        }
      });
      

      for (var prop in this.opts)
      {
        if (prop != "supercluster")
          this.featureLayerOpts[prop] = this.opts[prop];
      }

      if (this.opts.url) delete this.opts.url;
      if (this.opts.source) delete this.opts.source;

      if (!this.opts.supercluster)
        this.opts.supercluster = {};
      
      if (this.opts.supercluster.initial || this.opts.supercluster.map || this.opts.supercluster.reduce)
      {
        console.log("Removing initial/map/reduce methods from supercluster options (define in a separate script).");
        if (this.opts.supercluster.initial) delete this.opts.supercluster.initial;
        if (this.opts.supercluster.map) delete this.opts.supercluster.map;
        if (this.opts.supercluster.reduce) delete this.opts.supercluster.reduce;
      }
      
      // This will store client-side features from the source feeature layer:
      this.currentFeatures = [];

      // This will store the graphics currently displayed in the main map view:
      this.currentClusters = [];

      this.view = null;
      this.allViews = [];

      // For convenience later on, this will make it easy to distinguish
      // between client-side cluster attributes, and attributes associated with
      // the underlying feature service ...
      this.clusterFieldNames = array.map(clusterFields, function(field) {
        return field.name;
      });

      // Any supercluster fields provided will be appended to the default
      // clusterFields.  They should be matched by any properties that are
      // defined/calculated by the supercluster initialize/map/reduce methods:
      var fields = this.opts.supercluster.fields || [];
      this.opts.fields = clusterFields.concat(array.filter(
        fields,
        lang.hitch(this, function(field){
          return this.clusterFieldNames.indexOf(field.name) == -1;
        }))
      );

      // If no supercluster popup template is provided, use a default template...
      this.opts.popupTemplate =
        this.opts.supercluster.popupTemplate || clusterPopupTemplate;

      this.opts.labelsVisible = this.opts.supercluster.labelsVisible || false;
      this.opts.labelSymbol =
        this.opts.supercluster.labelSymbol || clusterLabelSymbol;
      this.opts.labelField =
        this.opts.supercluster.labelField || "point_count_abbreviated";
      this.opts.labelFormatter =
        this.opts.supercluster.labelFormatter || null;

      // Renderer can be anything, but should define appropriate symbols based
      // on point_count, or any other attribute calculated by the SuperCluster
      // reduce() method.  Must be part of the supercluster parameters...
      this.opts.renderer =
        this.opts.supercluster.renderer || clusterRenderer;

      this.opts.geometryType = "point";
      this.opts.spatialReference = { wkid: 4326 };
      this.opts.objectIdField = "cluster_id";

      this.opts.source = [];

      return this.inherited(arguments);
    },

    // Proxy the apply edits...
    applyEdits: function(){
      var promise = this.source_layer.applyEdits.apply(this, arguments);
      promise.when(lang.hitch(this, function(){ this.loadFeatures(); }));
      return promise;
    },

    // The zoom level and extent used to define clustering will be based on the
    // first view that the layer is added to...
    createLayerView: function(mapView) {
      if (!this.view) this.view = mapView;
      this.allViews.push(mapView);

      if (this.opts.labelsVisible) {
        this.labelGraphics = new GraphicsLayer({ graphics: [] });
        this.view.map.add(this.labelGraphics);
      }

      if (this.clusterWorkerReady)
      {
        this.initClusterLayer();
      }

      return this.inherited(arguments);
    },

    // If the layer is removed from a view, switch to the next view (if the
    // layer has been added to more than one), or set this.view = null
    destroyLayerView: function(mapView) {
      this.allViews.splice(this.allViews.indexOf(mapView), 1);
      if (this.allViews.indexOf(this.view) == -1)
      {
        if (this.allViews.length > 0) this.view = this.allViews[0];
        else this.view = null;
      }

      return this.inherited(arguments);
    },

    initClusterLayer: function(e){
      if (this.featureLayerOpts.url && !this.featureLayerOpts.direct_url)
      {
        this.source_layer = new FeatureLayer(this.featureLayerOpts);
        this.source_layer.load().then(lang.hitch(this, function(){
          this.definitionExpression = this.source_layer.definitionExpression;
          this.view.watch("stationary", lang.hitch(this, this.requestClusters));

          this.watch("definitionExpression", function(newExp, oldExp) {
            this.source_layer.definitionExpression = newExp;
            this.loadFeatures();
          });

          this.loadFeatures();
        }), function(e) {
          console.log("Error: ", e);
        });
      } else {
        this.view.watch("stationary", lang.hitch(this, this.requestClusters));
        this.loadFeatures();
      }
    },

    loadFeatures: function(where, offset) {
      
      // Initialize the ClusterWorker if it hasn't been done yet...
      if (!this.clusterIndexReady) this.worker.postMessage({opts: this.opts.supercluster});
      
      // If this was instantiated with client-side graphics, then just load
      // the supercluster index once...
      if (this.featureLayerOpts.source)
      {
        if (this.currentFeatures.length > 0) return;

        this.worker.postMessage({
          features: this.featureLayerOpts.source,
          type: "esri",
          load: true
        });

        return;
      }
      
      // If this was instantiated with url, and direct_url==true, then pass the URL to
      // the ClusterWorker, and let it load the URL as a raw JSON source...
      if (this.featureLayerOpts.url && this.featureLayerOpts.direct_url)
      {
        if (this.currentFeatures.length > 0) return;
        
        // The direct_type can specify "esri" for an Esri FeatureSet JSON 
        // representation, "coords" for an array of
        // raw lon/lat pairs, or "geojson"...
        this.worker.postMessage({
          url: this.featureLayerOpts.url,
          load: true,
          type: this.featureLayerOpts.direct_type || "geojson"
        });

        return;
      }
      
      // Setup default parameters...
      where = where || this.source_layer.definitionExpression || "1=1";
      offset = offset || 0;

      // If this is a new query, then initialize a new geojson features object
      if (offset == 0) this.currentFeatures = [];

      // Get appropriate outFields to ask for when querying the underlying
      // feature layer...this must exclude the clusterFieldNames (which are
      // generated locally by the supercluster module)...
      var outFields = array.filter(this.source_layer.outFields, lang.hitch(
        this,
        function(fieldname){
          return this.clusterFieldNames.indexOf(fieldname) == -1;
        })
      );

      if (outFields.length == 0) outFields = [this.source_layer.objectIdField];

      // Define the query parameters...
      var query = new Query({
        num: this.source_layer.maxRecordCount || 1000,
        start: offset,
        where: where,
        outFields: outFields,
        outSpatialReference: {wkid: 4326},
        returnGeometry: true
      });

      // Define a method in scope that will handle the query response...
      var handleQueryResponse = lang.hitch(this, function(results){

        // Pass features to the cluster worker (as plain JSON).
        this.worker.postMessage({
          features: results.features.map(esriObjectToJSON), 
          type: "esri", 
          load: !results.exceededTransferLimit
        });
        
        // Keep querying for more...
        if (results.exceededTransferLimit) {
          query.start += results.features.length;
          this.source_layer.queryFeatures(query).then(handleQueryResponse);
        }
      });

      // Start querying the underlying layer for features...
      this.source_layer.queryFeatures(query).then(handleQueryResponse);
    },

    requestClusters: function(stationary) {

      if (!stationary) return;

      if (this.clusterIndexReady && this.view) {

        var zoom = parseInt(Math.round(this.view.zoom));

        var extent = webMercatorUtils.webMercatorToGeographic(
          zoom < 5 ? this.view.map.basemap.baseLayers.items[0].fullExtent
            : this.view.extent
        );
        
        this.worker.postMessage({bbox: [extent.xmin, extent.ymin, extent.xmax, extent.ymax], zoom: zoom});
      }
    },
    
    displayClusters: function(clusters) {
      this.currentClusters = array.map(clusters, graphicFromGeoJson);

      if (this.labelGraphics) this.labelGraphics.removeAll();
      this.source.removeAll();
      this.source.addMany(this.currentClusters);
      if (this.labelGraphics) this.labelGraphics.addMany(array.map(
        array.filter(this.currentClusters, lang.hitch(
          this,
          function (cluster) {
            return cluster.attributes.point_count > 0;
          }
        )), lang.hitch(this, function(cluster) {
          var c = cluster.clone();
          c.symbol = new TextSymbol(lang.mixin(
            {},
            this.opts.labelSymbol,
            {text: this.opts.labelFormatter ? this.opts.labelFormatter(
              c.attributes[this.opts.labelField]
            ) : c.attributes[this.opts.labelField]}
          ));
          return c;
        })
      ));
    }
  });
  
  function esriObjectToJSON(obj) {
    return obj.toJSON();
  }
  
  // Convert GeoJSON point objects to Esri Graphic objects:
  function graphicFromGeoJson(geoJson){
    try
    {
      return new Graphic(
        {
          geometry: {
            type: "point",
            longitude: geoJson.geometry.coordinates[0],
            latitude: geoJson.geometry.coordinates[1]
          },
          attributes: geoJson.properties
        }
      );
    } catch (e) {
      console.log('Error converting GeoJSON to Graphic:', e);
    }
  }

});
